/**
 * DeepSeek AI Content Generator for Contentful Blog Posts
 * Generates blog content using DeepSeek AI and creates Contentful entries
 */

interface BlogPostData {
  title: string;
  slug: string;
  content: string;
  excerpt: string;
  seoTitle: string;
  seoDescription: string;
  tags: string[];
  readingTime: number;
}

interface DeepSeekResponse {
  choices: Array<{
    message: {
      content: string;
    };
  }>;
}

export class DeepSeekContentGenerator {
  private apiKey: string;
  private baseUrl = 'https://api.deepseek.com/v1';

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  /**
   * Generate a complete blog post using DeepSeek AI
   */
  async generateBlogPost(topic: string, authorId: string, categoryId: string): Promise<BlogPostData> {
    const prompt = this.createBlogPrompt(topic);
    
    try {
      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'deepseek-chat',
          messages: [
            {
              role: 'system',
              content: 'You are an expert content writer specializing in compliance, whistleblowing, and corporate governance. Create engaging, SEO-optimized blog posts.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.7,
          max_tokens: 2000
        })
      });

      if (!response.ok) {
        throw new Error(`DeepSeek API error: ${response.statusText}`);
      }

      const data: DeepSeekResponse = await response.json();
      const generatedContent = data.choices[0]?.message?.content;

      if (!generatedContent) {
        throw new Error('No content generated by DeepSeek');
      }

      return this.parseGeneratedContent(generatedContent, topic);
    } catch (error) {
      throw error;
    }
  }

  /**
   * Create a comprehensive prompt for blog post generation
   */
  private createBlogPrompt(topic: string): string {
    return `Create a comprehensive blog post about "${topic}" for a whistleblowing and compliance platform.

Requirements:
- Title: Catchy and SEO-friendly (50-60 characters)
- Slug: URL-friendly version of title (lowercase, hyphens)
- Content: Well-structured with headings, paragraphs (800-1200 words)
- Excerpt: Compelling summary (150-200 characters)
- SEO Title: Optimized for search engines (30-60 characters)
- SEO Description: Meta description (120-160 characters)
- Tags: 3-5 relevant tags
- Reading Time: Estimate in minutes

Tone: Professional yet accessible, authoritative but not intimidating
Target Audience: Compliance professionals, whistleblowers, HR managers, legal teams

Format the response as JSON with this exact structure:
{
  "title": "Your Title Here",
  "slug": "your-slug-here",
  "content": "Your full blog content with proper HTML formatting",
  "excerpt": "Your compelling excerpt here",
  "seoTitle": "SEO Optimized Title",
  "seoDescription": "SEO meta description here",
  "tags": ["tag1", "tag2", "tag3"],
  "readingTime": 5
}`;
  }

  /**
   * Parse the generated content into structured data
   */
  private parseGeneratedContent(content: string, topic: string): BlogPostData {
    try {
      // Try to extract JSON from the response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return {
          title: parsed.title || `Complete Guide to ${topic}`,
          slug: parsed.slug || this.generateSlug(parsed.title || topic),
          content: parsed.content || content,
          excerpt: parsed.excerpt || this.generateExcerpt(content),
          seoTitle: parsed.seoTitle || parsed.title,
          seoDescription: parsed.seoDescription || parsed.excerpt,
          tags: parsed.tags || this.generateTags(topic),
          readingTime: parsed.readingTime || this.estimateReadingTime(content)
        };
      }
    } catch (error) {
      
    }

    // Fallback: generate basic structure from content
    return {
      title: `Complete Guide to ${topic}`,
      slug: this.generateSlug(topic),
      content: content,
      excerpt: this.generateExcerpt(content),
      seoTitle: `Complete Guide to ${topic}`,
      seoDescription: this.generateExcerpt(content),
      tags: this.generateTags(topic),
      readingTime: this.estimateReadingTime(content)
    };
  }

  /**
   * Generate URL-friendly slug
   */
  private generateSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .trim();
  }

  /**
   * Generate excerpt from content
   */
  private generateExcerpt(content: string): string {
    const cleanContent = content.replace(/<[^>]*>/g, '');
    return cleanContent.substring(0, 200).trim() + '...';
  }

  /**
   * Generate relevant tags
   */
  private generateTags(topic: string): string[] {
    const baseTags = ['compliance', 'whistleblowing', 'corporate governance'];
    const topicTags = topic.toLowerCase().split(' ').slice(0, 2);
    return [...baseTags, ...topicTags].slice(0, 5);
  }

  /**
   * Estimate reading time
   */
  private estimateReadingTime(content: string): number {
    const wordsPerMinute = 200;
    const wordCount = content.split(/\s+/).length;
    return Math.max(1, Math.ceil(wordCount / wordsPerMinute));
  }
}

/**
 * Create Contentful entry from generated blog post data
 */
export async function createContentfulBlogPost(
  blogData: BlogPostData,
  authorId: string,
  categoryId: string
) {
  // This would use the Contentful MCP tools
  // For now, return the structured data
  return {
    fields: {
      title: { 'en-US': blogData.title },
      slug: { 'en-US': blogData.slug },
      content: { 'en-US': blogData.content },
      excerpt: { 'en-US': blogData.excerpt },
      seoTitle: { 'en-US': blogData.seoTitle },
      seoDescription: { 'en-US': blogData.seoDescription },
      tags: { 'en-US': blogData.tags },
      readingTime: { 'en-US': blogData.readingTime },
      publishDate: { 'en-US': new Date().toISOString() },
      status: { 'en-US': 'draft' },
      author: { 'en-US': { sys: { id: authorId, linkType: 'Entry', type: 'Link' } } },
      categories: { 'en-US': [{ sys: { id: categoryId, linkType: 'Entry', type: 'Link' } }] }
    }
  };
}
